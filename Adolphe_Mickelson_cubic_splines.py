import numpy as np
import matplotlib.pyplot as plt
import scipy.linalg
import gaussian_elimination

######################################################################

def get_spline_matvec(y_values):

    '''Constructs the A matrix and b vector for a given set of y values
    such that the solution D of the system A*D = b can be further
    refined to give the cubic spline coefficients.

    Parameters: 
    y_values: flat numpy array of length n+1

    Returns:
    A: (n+1) by (n+1) array of coefficients
    b: (n+1) array of right-hand-side values.'''

    n = y_values.shape[0] - 1

    A = np.zeros((n+1, n+1))
    b = np.zeros_like(y_values)

    
    m, n = A.shape
    
    A[0][0] = 2.0
    A[0][1] = 1.0
    
    for i in range(1,m):
            A[i][i-1] = 1.0
            A[i][i] = 4.0
            if (i < m-1):
                A[i][i+1] = 1.0
                
    A[m-1][n-1] = 2.0
    A[m-1][n-2] = 1.0    
     
    b[0] = 3*(y_values[1]-y_values[0])
    for i in range(1,m-1):
        b[i] = 3*(y_values[i+1]-y_values[i-1])
  
    b[m-1] = 3*(y_values[-1]-y_values[-2])
    ##################################################

    return A, b

######################################################################

def get_coeffs(y_values, D_values):

    '''Computes the n spline coefficients for given sets of n+1 
    y values and n+1 D values.

    Parameters: 
    y_values: flat numpy array of length n+1
    D_values: flat numpy array of length n+1

    Returns:
    coeffs: n by 4 array of matrix coefficients of
            the form ai, bi, ci, di, where the i'th
            spline function is given by 

            Yi(t) = ai + bi * t + ci * t^2 + di * t^3
    '''

    n = y_values.shape[0] - 1

    if y_values.shape != D_values.shape:
        raise RuntimeError('y values and D values should have same shape!')
    start  = np.zeros((n+1, 4))
    coeffs = np.zeros((n, 4))

    
    a = y_values
    b = D_values
    c = np.zeros_like(y_values,float)
    d = np.zeros_like(y_values,float)

    for i in range(n):
        c[i] = 3*(y_values[i+1]-y_values[i]) - 2*D_values[i]-D_values[i+1]

        d[i] = 2*(y_values[i]-y_values[i+1]) + D_values[i]+D_values[i+1]
    
    start[:,0] = a
    start[:,1] = b
    start[:,2] = c
    start[:,3] = d
    coeffs = start[:-1] # removes last row

    
    ##################################################

    return coeffs
    
######################################################################

def make_plot(y_values, coeffs):

    '''Plots the uniformly-spaced data points from the given y_values
    against the cubic splines generated by the coeffs array.'''


    fig, ax = plt.subplots()

    n = y_values.shape[0] - 1

    u = np.linspace(0, n, 100*n + 1)

    i = np.minimum(np.floor(u).astype(np.int32), n-1)

    t = u - i 
    
    ai = coeffs[i, 0]
    bi = coeffs[i, 1]
    ci = coeffs[i, 2]
    di = coeffs[i, 3]

    y = ai + t * (bi + t * (ci + t * di))

    u_values = np.arange(n+1)

    # plot y values as red dots
    ax.plot(u_values, y_values, 'ro', label='Original data points', zorder=2)
    ax.plot(u, y, 'b-', label='Interpolation curve', zorder=1)

    ax.legend()

    ax.set_title('Cubic spline interpolation')

    plt.show()

######################################################################

def GaussSeidel(A, b, y_values, tol=1e-12):
    x = np.zeros_like(y_values)
    xp = np.zeros_like(y_values)
    ea = np.zeros_like(y_values)
    
    m, n = A.shape
    cond = False
    '''
    loop until a all guesses are under a certain tolerence
    '''
    
    while(not cond):
    #for i in range(50):
        for i in range (0,m):
            xp[i] = x[i]
            x[i] = b[i]
            for j in range(0,n):
                if (i != j):
                    x[i] -=  A[i][j]*x[j]
            x[i] /= A[i][i]
        
        #ea = abs(x - xp)/x
        for i in range(x.size):
            if x[i] != 0.0:
                ea[i] = abs(x[i] - xp[i]) / x[i]
            else:
                ea[i] = 0.0
        cond = all(ele < tol for ele in ea)

        
    return x

def main():

    # get nicer looking printouts from numpy
    # without scientific notation

    np.set_printoptions(suppress=True)

    
    #y_values = np.array([1, 3.0, 2, 4, 1, 6, 1])
    #y_values = np.array([0, 3.0, 2, 4, 6, 1])
    #y_values = np.array([0, 1.0, 2, 4, 1, 6, 1])
    y_values = np.array([1, 1.5, 2, 8, 2, 1.5, 1])

    A, b = get_spline_matvec(y_values)

    print('A is')
    print(A)
    print()

    print('b is')
    print(b)
    print()


    #   - implementation of Gauss-Seidel iteration
    
    D_values = gaussian_elimination.solve_ge(A, b, tol=1e-12)
    print("D original:", D_values)
    ND_values = GaussSeidel(A, b, y_values)
    print("New D values:", ND_values)

    coeffs = get_coeffs(y_values, D_values)

    print('coeffs are')
    print(coeffs)
    print()

    make_plot(y_values, coeffs)

######################################################################

main()
